<div class='container'>
    <div class='expressionContainer'>
        <div class='indicator'></div>
        <span class='expression'>{{Expression}}</span>
    </div>

    <div class='hint'>{{Hint}}</div>
</div>

<script>
    function showRedWarning() {
        // if there's an error somewhere in the other <script>
        // it would never get to hideRedWarning() and we'd see a warning

        let expressionElement = document.querySelector('.expression')
        expressionElement.classList.add('superError')
    }

    showRedWarning()
</script>

<script>
    // ---------------- GLOBAL ----------------

    function defineConstants() {
        riverAnkiNextDayHour = 9

        // --- KEYBINDS ---

        riverToggleBlurKey = 'j'
        riverCycleFontKey = 'h'

        // --- FONTS ---

        riverFonts = 'font-notosans font-hiraginosans font-hiraginomincho font-hiraginominchobold font-ackaisyo'

        riverFontRegular = 'font-notosans'
        riverFontHandwritten = 'font-ackaisyo'

        riverFontProbabilities = [
            ['font-hiraginosans', 0.375],
            ['font-hiraginomincho', 0.24],
            ['font-hiraginominchobold', 0.01]
        ]

        // --- PREVIEW ---

        riverUsePreview = true
        riverPreviewProbabilityBloodMoon = 0
        riverPreviewProbabilityHoliday = 0
        riverPreviewProbabilityHandwritten = 0.01

        riverPreviewFontRegularOverride = null // can be null
        riverPreviewFontProbabilitiesOverride = [ // can be null
            ['font-hiraginosans', 0.2],
            ['font-hiraginomincho', 0.4],
            ['font-hiraginominchobold', 0.2]
        ]

        // --- READING KANA ---

        riverProbabilityReadingHiragana = 0.66

        // --- ENGLISH TEXT BLUR ---

        riverBlurMinInterval = 0 // days
        riverBlurMaxInterval = 50
        riverBlurMinBlur = 0 // em
        riverBlurMaxBlur = 0.12 // 0.1 = readable, 0.14 = barely readable, 0.2 = unreadable

        // --- HANDWRITTEN ---

        riverProbabilityKanaCardHandwritten = 0.2
        riverProbabilityNewKanjiCardHandwritten = 0.001
        riverProbabilityKanjiCardHandwritten = 0.04

        // --- BLOOD MOON ---

        riverProbabilityBloodMoon = 0.01
        riverBloodMoonProbabilityKanaCardHandwritten = 0.6
        riverBloodMoonProbabilityNewKanjiCardHandwritten = 0.01
        riverBloodMoonProbabilityKanjiCardHandwritten = riverProbabilityKanjiCardHandwritten * 2

        // --- HOLIDAY ---

        riverProbabilityHoliday = 0.01
        riverHolidayProbabilityNewKanjiCardHandwritten = 0
        riverHolidayProbabilityHandwritten = 0.01
    }

    function defineCardVariables() {
        // backticks to avoid single and double quotes in anki fields escaping the string literal
        cardExpression = `{{Expression}}`
        cardHint = `{{Hint}}`
        cardTrueReading = `{{Reading}}`
        cardMeaning = `{{Meaning}}`
        cardNotes = `{{Notes}}`
        cardTrueSentence = `{{Sentence}}`
        cardPitchPosition = `{{PitchPosition}}`

        // additional anki fields addon
        let cardType = `{{info-Type:}}`

        // only use this variable when (cardIsReview == true)
        // because after grading it wrong it immediately gets a new shorter interval
        cardInterval = Number(`{{info-Ivl:}}`)

        cardIsNew = cardType === '0'
        let cardIsLearning = cardType === '1'
        cardIsReview = cardType === '2'
        // let cardIsRelearning = cardType === '3'

        cardIsNewOrLearning = cardIsNew || cardIsLearning

        cardReading = cardTrueReading === '' ? cardExpression : cardTrueReading
        cardSentence = cardTrueSentence === '' ? cardExpression : cardTrueSentence

        riverIsFrontOfCard = getIsFrontOfCard()
        riverIsKatakanaCard = getIsKatakanaCard(cardExpression)
        riverIsKanaCard = cardReading === cardExpression

        riverIsPreview = riverUsePreview && getIsPreview()
    }

    function defineRandomVariables() {
        let seed = cardSentence
        let cardAgnosticSeed = ''

        let probabilityBloodMoon = riverProbabilityBloodMoon
        let probabilityHoliday = riverProbabilityHoliday

        if (riverIsPreview) {
            seed += 'river'
            cardAgnosticSeed += 'agnostic'

            probabilityBloodMoon = riverPreviewProbabilityBloodMoon
            probabilityHoliday = riverPreviewProbabilityHoliday
        }

        let random = getRandom(seed)
        let cardAgnosticRandom = getRandom(cardAgnosticSeed)

        riverIsBloodMoon = cardAgnosticRandom() < probabilityBloodMoon
        riverIsHoliday = cardAgnosticRandom() < probabilityHoliday

        riverCardFont = getTodaysFont(cardAgnosticRandom())

        riverIsHiraganaReading = random() < riverProbabilityReadingHiragana
        riverIsHandwrittenCard = random() < getProbabilityCardHandwritten()

        riverVariedKanaReading = getVariedKanaReading()

        if (riverIsBloodMoon) {
            riverIsHoliday = false
        }
    }

    function defineGlobalVariables() {
        defineConstants()
        defineCardVariables()
        defineRandomVariables()
    }

    // ---------------- GENERAL ----------------

    function indicateCard() {
        let indicatorElement = document.querySelector('.indicator')

        if (riverIsPreview) {
            indicatorElement.classList.add('visibleIndicator', 'indicatorPreview')
            return
        }

        if (cardIsNew) {
            indicatorElement.classList.add('visibleIndicator', 'indicatorNew')
            return
        }
    }

    function addLinkToExpression() {
        let useFurigana = false
        let expressionElement = document.querySelector('.expression')

        let rawExpression = useFurigana ? makeFuriganaExpression(cardExpression, cardReading) : null
        let linkElement = makeDictionaryLinkElement(cardExpression, rawExpression)

        expressionElement.replaceChildren(linkElement)
    }

    function fixCopypaste() {
        let expressionElement = document.querySelector('.expression')
        expressionElement.oncopy = (e) => {
            e.clipboardData.setData('text/plain', cardExpression)
            e.preventDefault()
        }
    }

    function populateReading() {
        let readingElement = document.querySelector('.reading')
        if (readingElement.childNodes.length > 0) {
            return
        }

        readingElement.innerHTML = cardExpression
    }

    function varyReadingKana() {
        let readingElement = document.querySelector('.reading')
        readingElement.innerHTML = riverVariedKanaReading
    }

    function addPitchToReading() {
        let readingElement = document.querySelector(".reading")
        let pitchPositions = getPitchPositions()
        if (!pitchPositions) {
            return
        }

        if (pitchPositions.some(p => p > getMoraLength())) {
            readingElement.classList.add('errorField')
            return
        }

        let pitchList = constructPitchList(pitchPositions)

        readingElement.replaceChildren(pitchList)
        readingElement.classList.add('pitch')
    }

    function addLinkToReading() {
        let readingElement = document.querySelector('.reading')
        let currentInner = readingElement.innerHTML
        let linkElement = makeGoogleImagesLinkElement(currentInner)

        readingElement.replaceChildren(linkElement)
    }

    function populateSentence() {
        let sentenceInnerElement = document.querySelector('.sentenceInner')
        if (sentenceInnerElement.childNodes.length > 0) {
            return
        }

        sentenceInnerElement.innerHTML = cardExpression
    }

    function populateHint() {
        let removeHintSymbol = '-'
        let copySentenceSymbol = 'c'

        let hintElement = document.querySelector('.hint')

        if (cardHint === removeHintSymbol) {
            hintElement.replaceChildren()
            return
        } else if (cardHint === copySentenceSymbol) {
            hintElement.innerHTML = cardSentence
            return
        }

        // if (hintElement.childNodes.length > 0) {
        //     return
        // }

        // if (!riverIsKanaCard || riverIsKatakanaCard) {
        //     return
        // }

        // hintElement.innerHTML = cardSentence
    }

    function markExpressionInSentence() {
        markExpressionInElement('hint')
        markExpressionInElement('sentence')
    }

    function markPitchInSentenceExpression() {
        let pitchPositions = getPitchPositions()
        if (!pitchPositions) {
            return
        }

        let pitchType = getPitchType(pitchPositions[0])

        // dont add pitch to hint to not make it easy
        let highlightedElements = document.querySelectorAll('.sentence b')
        highlightedElements.forEach((element) => {
            element.classList.add('pitch-underline', pitchType)
        })
    }

    function highlightErrorsInFields() {
        highlightErrorInExpression()
        highlightErrorInReading()
        highlightErrorInMeaning()
        highlightErrorInNotes()
        highlightErrorInSentence()
        highlightErrorInHint()
    }

    function highlightNotes() {
        let noteElement = document.querySelector('.notes')
        if (noteElement.childNodes.length === 0) {
            return
        }
        
        let noteGroups = getNoteGroups(noteElement)
        let simpleLines = noteGroups.simpleLines
        let definitionElements = noteGroups.definitionElements

        let simpleSectionElement = document.createElement('div')
        simpleSectionElement.classList.add('noteSimpleSection')

        simpleLines.forEach(line => {
            simpleSectionElement.appendChild(document.createTextNode(line))
            simpleSectionElement.appendChild(document.createElement('br'))
        })

        simpleSectionElement.lastChild?.remove() // dont need last <br>

        let definitionSectionElement = document.createElement('div')
        definitionSectionElement.classList.add('noteDefinitionSection')

        definitionElements.forEach(element => {
            definitionSectionElement.appendChild(element)
            definitionSectionElement.appendChild(document.createElement('br'))
        })

        definitionSectionElement.lastChild?.remove() // dont need last <br>

        noteElement.replaceChildren()
        
        if (simpleLines.length !== 0) {
            noteElement.appendChild(simpleSectionElement)
        }

        if (definitionElements.length !== 0) {
            noteElement.appendChild(definitionSectionElement)
        }
    }

    function blurEnglishText() {
        let englishElements = document.querySelectorAll('.meaning, .definitionMeaning, .noteSimpleSection')
        englishElements = Array.from(englishElements).filter(element => !getIsJapanese(element.textContent))

        setBlurAmount()

        let toggleBlur = () => {
            englishElements.forEach(element => {
                element.classList.toggle('blurry')
            })
        }

        if (cardIsReview) {
            toggleBlur()
        }

        addEventListener('keypress', (e) => {
            if (e.key === riverToggleBlurKey) {
                toggleBlur()
            }
        })
    }

    function varyJapaneseFont() {
        tagJapaneseText()
        varyCardJapaneseFont()
        // varyReadingJapaneseFont()
    }

    function hideRedWarning() {
        let expressionElement = document.querySelector('.expression')
        expressionElement.classList.remove('superError')
    }

    // ---------------- MISC ----------------

    function getRandom(stringSeed) {
        let getRandomSeed = () => {
            // different seed every day for each card

            let ankiNextDayHour = riverAnkiNextDayHour

            let oneDayMs = 24 * 60 * 60 * 1000
            let date = new Date()
            let timeMs = date.getTime() - date.getTimezoneOffset() * 60 * 1000
            let adjustedTimeMs = timeMs - ankiNextDayHour * 60 * 60 * 1000
            let adjustedDay = Math.floor(adjustedTimeMs / oneDayMs)

            let numberForToday = adjustedDay % 10000
            let cardNumber = [...stringSeed].map(c => c.charCodeAt(0)).reduce((a, b) => a + b, 0) % 10000

            return numberForToday + cardNumber
        }

        let seed = getRandomSeed()
        return () => {
            let x = Math.sin(seed++) * 10000
            return x - Math.floor(x)
        }
    }

    function getIsKana(char) {
        // src: https://stackoverflow.com/a/43419070
        return /[\u3040-\u30ff]/.test(char)
    }

    function getIsJapanese(text) {
        let regex = /[\u3000-\u303f\u3040-\u309f\u30a0-\u30ff\uff00-\uff9f\u4e00-\u9faf\u3400-\u4dbf]/
        return text.match(regex) !== null
    }

    function getIsKatakanaCard(expression) {
        let isKatakana = w => [...w].some(c => c.charCodeAt(0) >= 12449 && c.charCodeAt(0) <= 12534)
        return isKatakana(expression)
    }

    function lerp(value, minIn, maxIn, minOut, maxOut) {
        let enableEase = true
        let ease = (x) => 0.5 - 0.5 * Math.cos(Math.PI * x)

        let scale = Math.min(1, Math.max(0, (value - minIn) / (maxIn - minIn)))
        if (enableEase) {
            scale = ease(scale)
        }
        
        return minOut + scale * (maxOut - minOut)
    }

    function setBlurAmount() {
        let blurAmount = lerp(
            cardInterval,
            riverBlurMinInterval,
            riverBlurMaxInterval,
            riverBlurMinBlur,
            riverBlurMaxBlur
        )

        let root = document.documentElement
        root.style.setProperty('--blur-amount', `${blurAmount}em`)
    }

    function getIsFrontOfCard() {
        let dividerElement = document.querySelector('.divider')
        return dividerElement === null
    }

    function getIsPreview() {
        // let viewportWidth = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0)
        let viewportHeight = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0)

        // review viewport: (969, 892)
        // preview viewport: (887, 829)
        return viewportHeight < 850
    }

    function translateKana(source, toHiragana) {
        let hira = "ぁあぃいぅうぇえぉおかがきぎくぐけげこごさざしじすずせぜそぞただちぢっつづてでとどなにぬねのはばぱひびぴふぶぷへべぺほぼぽまみむめもゃやゅゆょよらりるれろゎわゐゑをんゔゕゖゝゞ";
        let kata = "ァアィイゥウェエォオカガキギクグケゲコゴサザシジスズセゼソゾタダチヂッツヅテデトドナニヌネノハバパヒビピフブプヘベペホボポマミムメモャヤュユョヨラリルレロヮワヰヱヲンヴヵヶヽヾ";

        let getIndices = (word, kana) => {
            return word.map(char => {
                let i = kana.indexOf(char)
                return i === -1 ? char : i
            })
        }

        let word = [...source]
        word = getIndices(word, hira)
        word = getIndices(word, kata)

        let targetKana = toHiragana ? hira : kata
        return word.map(i => typeof i === 'number' ? targetKana[i] : i).join('')
    }

    // ---------------- RANDOMNESS ----------------

    function getProbabilityCardHandwritten() {
        if (riverIsPreview) {
            return riverPreviewProbabilityHandwritten
        }

        if (riverIsHoliday) {
            if (cardIsNewOrLearning && !riverIsKanaCard) {
                return riverHolidayProbabilityNewKanjiCardHandwritten
            }
            
            return riverHolidayProbabilityHandwritten
        }

        if (riverIsKanaCard) {
            if (riverIsBloodMoon) {
                return riverBloodMoonProbabilityKanaCardHandwritten
            }

            return riverProbabilityKanaCardHandwritten
        }
        
        if (cardIsNewOrLearning) {
            if (riverIsBloodMoon) {
                return riverBloodMoonProbabilityNewKanjiCardHandwritten
            }

            return riverProbabilityNewKanjiCardHandwritten
        }

        if (riverIsBloodMoon) {
            return riverBloodMoonProbabilityKanjiCardHandwritten
        }

        return riverProbabilityKanjiCardHandwritten
    }

    // ---------------- FONT VARIATION ----------------

    function getFonts() {
        return riverFonts.split(' ')
    }

    function cycleFont(element) {
        let fonts = getFonts()

        let currentFont = riverFontRegular
        for (const font of fonts) {
            if (element.classList.contains(font)) {
                currentFont = font
                break
            }
        }

        newFont = fonts[(fonts.indexOf(currentFont) + 1) % fonts.length]

        element.classList.remove(currentFont)
        element.classList.add(newFont)
    }

    function setFont(element, font) {
        let fonts = getFonts()
        element.classList.remove(...fonts)
        element.classList.add(font)
    }

    function tagJapaneseText() {
        // we tag these elements because they could be either english or japanese

        let elements = document.querySelectorAll('.meaning, .definitionMeaning, .noteSimpleSection')
        let japaneseElements = Array.from(elements).filter(element => getIsJapanese(element.textContent))

        japaneseElements.forEach((element) => {
            element.classList.add('japanese')
        })
    }

    function getTodaysFont(random) {
        // every day has a new font cuz random is card-agnostic

        let regularFont = riverFontRegular
        let fontProbabilities = riverFontProbabilities

        if (riverIsPreview) {
            if (riverPreviewFontRegularOverride !== null) {
                regularFont = riverPreviewFontRegularOverride
            }

            if (riverPreviewFontProbabilitiesOverride !== null) {
                fontProbabilities = riverPreviewFontProbabilitiesOverride
            }
        }

        if (fontProbabilities.length === 0) {
            return regularFont
        }

        let value = random
        for (let i = 0; i < fontProbabilities.length; i++) {
            let [currentFont, currentProbability] = fontProbabilities[i]

            if (value < currentProbability) {
                return currentFont
            }

            value -= currentProbability
        }

        return regularFont
    }

    function getCurrentFont() {
        if (riverIsHandwrittenCard) {
            return riverFontHandwritten
        }
        
        return riverCardFont
    }

    function varyCardJapaneseFont() {
        let japaneseElementSelector = '.expression, .hint, .sentenceInner, .definitionExpression, .definitionReading, .japanese'
        let elements = document.querySelectorAll(japaneseElementSelector)

        let font = getCurrentFont()
        elements.forEach((element) => {
            setFont(element, font)
        })

        let cycleCardFont = () => {
            elements.forEach((element) => {
                cycleFont(element)
            })
        }

        addEventListener('keypress', (e) => {
            if (e.key === riverCycleFontKey) {
                cycleCardFont()
            }
        })

        let cycleFontButton = document.querySelector('.cycleFontButton')
        cycleFontButton?.addEventListener('click', (e) => {
            cycleCardFont()
        })
    }

    // ---------------- KANA VARIATION ----------------

    function getVariedKanaReading() {
        if (cardReading.includes('ー')) { // katakana prolongation mark
            return cardReading
        }

        return translateKana(cardReading, riverIsHiraganaReading)
    }

    // ---------------- LINK ADDING ----------------

    function makeLinkElement(link, inner) {
        let linkElement = document.createElement('a')
        linkElement.setAttribute('href', link)
        linkElement.innerHTML = inner

        return linkElement
    }

    function makeDictionaryLinkElement(expression, rawContent) {
        let link = `https://jisho.org/search/${expression}`
        return makeLinkElement(link, rawContent ?? expression)
    }

    function makeGoogleImagesLinkElement(inner) {
        // let link = `https://www.google.com/search?q=${cardExpression}&udm=2`
        let link = `https://www.google.com/search?q=${cardExpression}&udm=2&lr=lang_ja`
        
        return makeLinkElement(link, inner)
    }

    // ---------------- EXPRESSION MARKING ----------------

    function getUnhighlightedIndices(sentence, expression, specialTagStart, specialTagEnd) {
        let index = 0
        let unhighlightedIndices = []

        while (true) {
            let expressionIndex = sentence.indexOf(expression, index)
            if (expressionIndex === -1) {
                break
            }

            let startTagIndex = sentence.indexOf(specialTagStart, index)

            if (startTagIndex === -1 || expressionIndex < startTagIndex) {
                unhighlightedIndices.push(expressionIndex)
                index = expressionIndex + expression.length
                continue
            }

            let startTagEndIndex = startTagIndex + specialTagStart.length
            let endTagIndex = sentence.indexOf(specialTagEnd, startTagEndIndex)
            if (endTagIndex === -1) {
                alert('Found unclosed special tag')
                break
            }

            index = endTagIndex + specialTagEnd.length
        }

        return unhighlightedIndices
    }

    function highlightExpression(sentence, expression, unhighlightedIndices, highlightTagStart, highlightTagEnd) {
        if (unhighlightedIndices.length === 0) {
            return sentence
        }

        let result = ''
        let index = 0
        for (let i = 0; i < unhighlightedIndices.length; i++) {
            let middleChunkLeftIndex = unhighlightedIndices[i]
            let middleChunkRightIndex = middleChunkLeftIndex + expression.length

            let leftChunk = sentence.substring(index, middleChunkLeftIndex)

            let middleChunk = sentence.substring(middleChunkLeftIndex, middleChunkRightIndex)
            if (middleChunk !== expression) {
                alert('Something went wrong')
            }

            result += leftChunk + highlightTagStart + expression + highlightTagEnd

            if (i + 1 === unhighlightedIndices.length) {
                let rightChunk = sentence.substring(middleChunkRightIndex, sentence.length)
                result += rightChunk
            }

            index = middleChunkRightIndex
        }

        return result
    }

    function autoBoldHighlight(sentence, expression) {
        let boldTagStart = '<b>'
        let boldTagEnd = '</b>'

        let unhighlightedIndices = getUnhighlightedIndices(sentence, expression, boldTagStart, boldTagEnd)
        let highlighted = highlightExpression(sentence, expression, unhighlightedIndices, boldTagStart, boldTagEnd)

        return highlighted
    }

    function markExpressionInElement(elementClass) {
        let element = document.querySelector('.' + elementClass)
        if (!element) {
            return
        }

        let sentence = element.innerHTML
        if (sentence.length === 0 || cardExpression.length === 0) {
            return
        }

        let expressionHighlighted = autoBoldHighlight(sentence, cardExpression)

        let hiraganaReading = translateKana(cardReading, true)
        let katakanaReading = translateKana(cardReading, false)

        let readingHighlighted
        if (cardReading === cardExpression) {
            readingHighlighted = expressionHighlighted
        } else {
            readingHighlighted = autoBoldHighlight(expressionHighlighted, cardReading)
        }

        if (cardReading !== hiraganaReading) {
            readingHighlighted = autoBoldHighlight(readingHighlighted, hiraganaReading)
        }

        if (cardReading !== katakanaReading) {
            readingHighlighted = autoBoldHighlight(readingHighlighted, katakanaReading)
        }

        element.innerHTML = readingHighlighted
    }

    // ---------------- ERROR CHECKING ----------------

    function checkHasWhitespaceOrEntity(targetString) {
        let hasWhitespaceAtEdges = targetString !== targetString.trim()
        let hasEntity = /\&[a-z]+;/.test(targetString) // &nbsp; and stuff

        return hasWhitespaceAtEdges || hasEntity
    }

    function checkHasSimpleError(targetString) {
        let hasWhitespaceOrEntity = checkHasWhitespaceOrEntity(targetString)
        let hasTag = /<\/?[a-z][\s\S]*>/i.test(targetString) // <br> and stuff

        return hasWhitespaceOrEntity || hasTag
    }

    function checkHasSentenceError(targetString) {
        let hasWhitespaceOrEntity = checkHasWhitespaceOrEntity(targetString)
        let hasNonBoldTag = /<\/?(?!b>)[a-z][\s\S]*>/i.test(targetString)

        return hasWhitespaceOrEntity || hasNonBoldTag
    }

    function highlightAsErroredIfNeeded(hasError, targetClass) {
        if (!hasError) {
            return
        }

        let targetElement = document.querySelector('.' + targetClass)
        if (!targetElement) {
            return
        }

        targetElement.classList.add('errorField')
    }

    function highlightErrorInExpression() {
        let targetClass = 'expression'
        let targetString = cardExpression

        let hasError = checkHasSimpleError(targetString)
        highlightAsErroredIfNeeded(hasError, targetClass)
    }

    function highlightErrorInReading() {
        let targetClass = 'reading'
        let targetString = cardTrueReading

        let hasError = checkHasSimpleError(targetString)
        highlightAsErroredIfNeeded(hasError, targetClass)
    }

    function highlightErrorInMeaning() {
        let targetClass = 'meaning'
        let targetString = cardMeaning

        let hasError = checkHasSimpleError(targetString)
        highlightAsErroredIfNeeded(hasError, targetClass)
    }

    function highlightErrorInNotes() {
        let targetClass = 'notes'
        let targetString = cardNotes

        let hasWhitespaceAtEdges = targetString !== targetString.trim()
        let hasNonNbspEntity = /\&(?!nbsp)[a-z]+;/.test(targetString) // &nbsp; is ok
        let hasNonBrTag = /<\/?(?!br)[a-z][\s\S]*>/i.test(targetString) // all tags except <br>
        let hasBrAtEdges = /^(<br>.*|.*<br>)$/i.test(targetString)

        let hasError = hasWhitespaceAtEdges || hasNonNbspEntity || hasNonBrTag || hasBrAtEdges
        highlightAsErroredIfNeeded(hasError, targetClass)
    }

    function highlightErrorInSentence() {
        let targetClass = 'sentence'
        let targetString = cardTrueSentence

        let hasError = checkHasSentenceError(targetString)
        highlightAsErroredIfNeeded(hasError, targetClass)
    }

    function highlightErrorInHint() {
        let targetClass = 'hint'
        let targetString = cardHint

        let hasError = checkHasSentenceError(targetString)
        highlightAsErroredIfNeeded(hasError, targetClass)
    }

    // ---------------- NOTE DEFINITION HIGHLIGHTING ----------------

    function splitIntoKanaGroups(expression) {
        let groups = []
        let chars = [...expression]
        let previousIsKana

        for (let i = 0; i < chars.length; i++) {
            let char = chars[i]
            let isKana = getIsKana(char)

            if (i === 0) {
                previousIsKana = isKana
                groups.push(char)
                continue
            }

            if (previousIsKana === isKana) {
                groups[groups.length - 1] = groups.at(-1) + char
            } else {
                groups.push(char)
            }

            previousIsKana = isKana
        }

        return groups
    }

    function recognizeReading(kanaGroups, expression, reading) {
        let rawRegex = kanaGroups.map(g => getIsKana(g) ? g : '(.+)').join('')
        let furiganaRegex = new RegExp(rawRegex)

        let recognized = furiganaRegex.exec(reading)
        if (recognized === null) {
            return [[expression, reading]]
        }

        let recognizedReadings = recognized.slice(1)
        return kanaGroups.map(g => getIsKana(g) ? [g] : [g, recognizedReadings.shift()])
    }

    function formatRecognized(recognizedGroups) {
        let rubyInner = recognizedGroups.map(group => {
            let element = group[0]
            let reading = group[1] ?? ''
            let switchedReading = translateKana(reading, riverIsHiraganaReading)

            return `${element}<rt>${switchedReading}</rt>`
        })

        return `<ruby>${rubyInner.join('')}</ruby>`
    }

    function makeFuriganaExpression(expression, reading) {
        if (reading === expression || reading === '') {
            return expression
        }

        let kanaGroups = splitIntoKanaGroups(expression)
        let recognizedGroups = recognizeReading(kanaGroups, expression, reading)

        return formatRecognized(recognizedGroups)
    }

    function highlightNoteDefinition(expression, reading, meaning) {
        let useFurigana = true

        let lineElement = document.createElement('span')
        lineElement.classList.add('definitionLine')

        let expressionElement = document.createElement('span')
        expressionElement.classList.add('definitionExpression')

        if (useFurigana) {
            let expressionWithFurigana = makeFuriganaExpression(expression, reading)
            let linkElement = makeDictionaryLinkElement(expression, expressionWithFurigana)
            expressionElement.appendChild(linkElement)

            lineElement.appendChild(expressionElement)
            lineElement.appendChild(document.createTextNode(' — '))
        } else {
            let linkElement = makeDictionaryLinkElement(expression)
            expressionElement.appendChild(linkElement)

            lineElement.appendChild(expressionElement)

            let readingElement = document.createElement('span')
            readingElement.classList.add('definitionReading')
            readingElement.appendChild(document.createTextNode(reading))

            lineElement.appendChild(document.createTextNode('「'))
            lineElement.appendChild(readingElement)
            lineElement.appendChild(document.createTextNode('」— '))
        }

        let meaningElement = document.createElement('span')
        meaningElement.classList.add('definitionMeaning')
        meaningElement.appendChild(document.createTextNode(meaning))

        lineElement.appendChild(meaningElement)
        return lineElement
    }

    function getNoteGroups(noteElement) {
        let removeMainDefinitionNote = true

        let noteRaw = noteElement.innerHTML.replaceAll('&nbsp;', ' ').trim()
        let lines = noteRaw.split('<br>')

        let simpleLines = []
        let definitionElements = []

        lines.forEach(line => {
            // definition examples:
            // 持ち上げる [もちあげる] - elevate
            // 収まる「おさまる」- fit into

            let definitionRegex = /^(.+?)\s*[「\[](.+)[」\]]\s*[-ー—]\s*(.+)$/

            let groups = definitionRegex.exec(line)
            if (groups === null) {
                simpleLines.push(line)
                return
            }

            let expression = groups[1].trim()
            let reading = groups[2].trim()
            let meaning = groups[3].trim()

            let isMainDefinition = expression == cardExpression && reading == cardReading
            if (removeMainDefinitionNote && isMainDefinition) {
                return
            }

            let highlightedDefinition = highlightNoteDefinition(expression, reading, meaning)
            definitionElements.push(highlightedDefinition)
        })

        return {
            simpleLines: simpleLines,
            definitionElements: definitionElements
        }
    }

    // ---------------- PITCH ACCENT ----------------

    function getSameMoraKana() {
        return 'ャュョァィゥェォヮゃゅょぁぃぅぇぉゎ'
    }

    function getMoraLength() {
        let regex = new RegExp(`[${getSameMoraKana()}]`, 'g')
        return cardReading.replace(regex, '').length
    }

    function getPitchPositions() {
        let positions = cardPitchPosition.match(/^\d+|\d+\b|\d+(?=\w)/g)
        if (positions === null) {
            return null
        }

        return positions.map(a => Number(a))
    }

    function getPitchType(pitchPosition) {
        let moraLength = getMoraLength()

        if (pitchPosition === 0) {
            return 'heiban'
        } else if (pitchPosition === 1) {
            return 'atamadaka'
        } else if (pitchPosition === moraLength) {
            return 'odaka'
        } else if (pitchPosition === moraLength - 1) {
            return 'kifuku' // not entirely correct but we're letting it slide
        } else {
            return 'nakadaka'
        }
    }

    function groupMoras(kana) {
        let currentChar = ''
        let nextChar = ''
        let groupedMoras = []
        let check = getSameMoraKana().split('')

        for (let i = 0; i < kana.length; i++) {
            currentChar = kana[i]
            nextChar = i < kana.length - 1 && kana[i + 1]

            if (check.includes(nextChar)) {
                groupedMoras.push(currentChar + nextChar)
                i += 1
            } else {
                groupedMoras.push(currentChar)
            }
        }

        return groupedMoras
    }

    function getPitchPattern(pitchPosition) {
        let low = '0'
        let high = '1'
        let drop = '2' // high to low

        let moras = groupMoras(cardReading)
        let pitchType = getPitchType(pitchPosition)
        let pattern = []

        if (pitchType === 'heiban') {
            pattern = [
                ...Array(moras[0].length).fill(low),
                ...Array(cardReading.length - moras[0].length).fill(high),
            ]
        } else if (pitchType === 'atamadaka') {
            pattern = [
                ...(moras[0].length === 2 ? [high, drop] : [drop]),
                ...Array(cardReading.length - moras[0].length).fill(low),
            ]
        } else if (pitchType === 'odaka') {
            pattern = [
                ...Array(moras[0].length).fill(low),
                ...Array(cardReading.length - moras[0].length - 1).fill(high),
                drop,
            ]
        } else { // nakadaka
            let afterDrop = false
            for (let i = 0; i < moras.length; i++) {
                if (i === 0) {
                    pattern = Array(moras[0].length).fill(low)
                } else if (i + 1 === pitchPosition) {
                    pattern =
                        moras[i].length === 2
                        ? [...pattern, high, drop]
                        : [...pattern, drop]
                    afterDrop = true
                } else if (afterDrop) {
                    pattern = [...pattern, ...Array(moras[i].length).fill(low)]
                } else {
                    pattern = [...pattern, ...Array(moras[i].length).fill(high)]
                }
            }
        }

        return pattern
    }

    function constructPitchList(pitchPositions) {
        let low = '0'
        let high = '1'
        let drop = '2' // high to low

        let createPitchSpan = (pitchClass, pitchChar) => {
            let pitchSpan = document.createElement('span')
            let charSpan = document.createElement('span')
            let lineSpan = document.createElement('span')

            pitchSpan.classList.add(pitchClass)
            charSpan.classList.add('pitch-char')
            charSpan.innerText = pitchChar
            lineSpan.classList.add('pitch-line')

            pitchSpan.appendChild(charSpan)
            pitchSpan.appendChild(lineSpan)

            return pitchSpan
        }

        let uniquePitchPositions = [...new Set(pitchPositions)]
        let pitchList = document.createElement('ul')

        for (let pitchPosition of uniquePitchPositions) {
            let pattern = getPitchPattern(pitchPosition)
            let pitchType = getPitchType(pitchPosition)

            let pitchItem = document.createElement('li')
            pitchItem.classList.add('pitch-item', pitchType)

            for (let i = 0; i < riverVariedKanaReading.length; i++) {
                let currentKana = riverVariedKanaReading[i]

                let className = null
                if (pattern[i] === low) {
                    className = 'pitch-low'
                }
                else if (pattern[i] === high) {
                    className = 'pitch-high'
                }
                else if (pattern[i] === drop) {
                    className = 'pitch-to-drop'
                } else {
                    // console.error('pattern[i] found undefined value. pattern is', pattern)
                    alert(`pattern[i] found undefined value. pattern is ${pattern}`)
                    break
                }

                let currentPitchSpan = createPitchSpan(className, currentKana)
                pitchItem.appendChild(currentPitchSpan)
            }
            
            pitchList.appendChild(pitchItem)
        }

        return pitchList
    }

    // ---------------- MAIN ----------------

    function mainFront() {
        indicateCard()
        addLinkToExpression()
        fixCopypaste()

        // populateReading()
        // varyReadingKana()
        // addPitchToReading()
        // addLinkToReading()

        // populateSentence()
        populateHint()
        markExpressionInSentence()
        // markPitchInSentenceExpression()
        
        highlightErrorsInFields()
        // highlightNotes()
        // blurEnglishText()
        varyJapaneseFont()
    }

    function mainBack() {
        indicateCard()
        addLinkToExpression()
        fixCopypaste()

        // populateReading()
        varyReadingKana()
        addPitchToReading()
        addLinkToReading()

        populateSentence()
        populateHint()
        markExpressionInSentence()
        markPitchInSentenceExpression()

        highlightErrorsInFields()
        highlightNotes()
        blurEnglishText()
        varyJapaneseFont()
    }

    function main() {
        defineGlobalVariables()

        if (riverIsFrontOfCard) {
            mainFront()
        } else {
            mainBack()
        }

        hideRedWarning()
    }

    main()
</script>
